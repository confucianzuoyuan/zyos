# 一些笔记

## lgdt 指令

在 x86-64 指令集中，`lgdt` 指令用于加载全局描述符表（Global Descriptor Table，GDT）的地址和大小。

GDT 是 x86 架构中用于管理内存段的数据结构，它包含了描述每个内存段属性的段描述符。`lgdt` 指令的作用是将 GDT 的地址和大小加载到 GDTR（GDT Register）寄存器中。

`lgdt` 指令的使用方法如下：

```assembly
lgdt [address]
```

其中，`[address]` 是一个指向 GDT 的地址和大小信息的内存位置的操作数。该内存位置应该包含一个 48 位的 GDT 描述符，其中低 32 位表示 GDT 的物理地址，高 16 位表示 GDT 的大小（以字节为单位）。

执行 `lgdt` 指令后，GDTR 寄存器会被加载为指定的 GDT 地址和大小，从而使得新的 GDT 生效。

需要注意的是，由于 `lgdt` 指令涉及到特权级的操作，因此在大多数情况下只能在操作系统内核或特权级代码中使用。在用户级别的应用程序中，通常无法直接使用 `lgdt` 指令。

## 字节数量

b: 一个字节，byte

w: 两个字节，word

d: 四个字节，doubleword

q: 八个字节，quadword

## A20地址总线

在`x86_64`架构中，`A20`地址线是一个特殊的硬件线路，它控制着计算机的内存访问方式。`A20`线的名称来源于它实际上是CPU的第21条地址线（计数从0开始）[1]。

在早期的IBM PC兼容机中，CPU（如Intel 8086）的地址总线只有20条线，因此，它们只能访问最多1MB的内存。然而，由于一种被称为"实模式内存环绕"的硬件bug，当CPU试图访问超过1MB的内存时，地址会"环绕"回到0，因此实际上可以访问到的内存空间只有1MB[2]。

后来，当Intel推出80286和80386等支持更多内存的CPU时，这个"环绕"问题就成了一个问题，因为它阻止了对超过1MB内存的访问。为了解决这个问题，IBM在其AT主机上引入了一个被称为"A20门"的硬件解决方案。通过控制这个"A20门"，可以启用或禁用第21条地址线（即A20线），从而开启或关闭地址环绕[2]。

在现代的`x86_64`架构中，虽然已经可以支持访问远超1MB的内存，但是"A20门"仍然被保留下来，主要是为了向后兼容。在某些情况下，例如在启动操作系统之前，可能仍然需要通过控制"A20门"来启用或禁用地址环绕[3]。

总的来说，`A20`地址总线是`x86_64`架构中的一个遗留硬件特性，它控制着计算机是否启用地址环绕。

## SSE

`SSE（Streaming SIMD Extensions）`是一种在`x86`架构中用于加速多媒体和通信应用的指令集扩展。这种指令集扩展引入了一种新的数据类型——单指令多数据（SIMD），可以让CPU在一个时钟周期内对多个数据进行相同的操作，从而显著提高处理效率[1]。

在原始的`SSE`指令集中，新增了8个128位的寄存器（xmm0～xmm7）。而在`x86_64`（也称为AMD64）架构中，又额外增加了8个寄存器，但这额外的8个寄存器只能在64位模式下使用[1]。

`SSE`指令集提供了对打包单精度浮点值的SIMD支持。数据被传送到XMM寄存器中。SSE指令有两个版本，后缀PS和后缀SS。PS是对打包单精度浮点值执行类型的运算操作，每个值都参与。SS结尾的，只对打包值中的低位双字执行[2]。

现代的`x86-64`架构支持多种向量指令集，其中包括`SSE`指令集。这个指令集支持对整数、单精度和双精度数据的向量操作[4]。

总的来说，`SSE`是一种在`x86_64`架构中用于加速多媒体和通信应用的指令集扩展。它引入了一种新的数据类型——单指令多数据（SIMD），并且提供了一系列用于处理这种数据类型的指令。

## 为什么要关闭 `CR0.EM` 这一位呢？

`CR0`是`x86`和`x86_64`架构中的一个控制寄存器，用于控制CPU的一些重要特性[2]。其中，`EM`位（即`CR0.EM`）是`CR0`寄存器的第二位，用于控制浮点数指令的执行方式。

当`CR0.EM`位被设置为1时，CPU会把所有的浮点数指令当作无效指令来处理，这样就可以在软件中模拟浮点数运算。这在早期的计算机中是非常有用的，因为那时候的计算机并不都有硬件浮点数单元（FPU）[1]。

然而，在现代的计算机中，几乎所有的CPU都内置了硬件FPU，因此通常不需要在软件中模拟浮点数运算。反而，如果`CR0.EM`位被设置为1，那么就会导致所有的浮点数指令都不能被硬件执行，从而降低运行效率。

因此，通常我们需要关闭`CR0.EM`位，也就是将其设置为0，以便让CPU可以直接执行浮点数指令。这样可以提高浮点数运算的效率，从而提高程序的运行速度。

## 为什么要开启 `CR0.MP` 位

`CR0.MP`位是`x86`和`x86_64`架构中控制寄存器`CR0`的一部分，它用于控制浮点数协处理器的行为[4]。

具体来说，当`CR0.MP`位被设置为1时，如果`CR0.TS`位也被设置为1，那么CPU会在执行浮点数指令或`WAIT/FWAIT`指令时产生一个设备不存在（Device Not Available）异常。这个异常可以被操作系统捕获，然后保存当前的浮点数状态，以便之后恢复[1]。

这个特性在多任务环境中是非常有用的，因为它可以让操作系统在任务切换时保存和恢复浮点数状态，从而保证每个任务的浮点数计算不会被其他任务影响。这是一种对浮点数协处理器进行上下文切换（context switch）的机制[4]。

因此，我们通常需要开启`CR0.MP`位，也就是将其设置为1，以便在多任务环境中正确地处理浮点数计算。

## TSS

在`x86-64`体系结构中，`Task State Segment`（TSS）是一种特殊的数据结构，用于存储关于任务的信息。操作系统内核使用TSS进行任务管理[1]。

具体来说，TSS中存储了以下信息：

- 处理器寄存器状态
- I/O端口权限
- 内部级别的堆栈指针
- 上一个TSS的链接[1]

在保护模式下，TSS主要适用于硬件任务切换，其中每个独立的任务都有自己的TSS[2]。

总的来说，`Task State Segment`在`x86-64`体系结构中用于存储关于任务的信息，以便操作系统内核进行任务管理和任务切换。

## 寄存器和指令

在`x86-64`体系结构中，`es`、`ds`、`cs`、`fs`和`ss`都是段寄存器，它们用于在内存分段模式下存储段选择子[1]。以下是它们各自的功能：

- `cs`（代码段寄存器）：用于存储当前正在执行的代码段的段选择子。当CPU执行跳转或调用指令时，`cs`寄存器的值会被更新[2]。

- `ds`（数据段寄存器）：用于存储当前正在使用的数据段的段选择子。大多数数据引用指令都会使用这个寄存器[2]。

- `ss`（堆栈段寄存器）：用于存储当前正在使用的堆栈段的段选择子。当CPU执行堆栈操作（如push和pop）时，会使用这个寄存器[2]。

- `es`（附加段寄存器）：在某些数据移动指令中，用于存储目标数据段的段选择子[2]。

- `fs`（附加段寄存器）：在某些操作系统和应用程序中，用于访问特定的数据结构，如线程局部存储（Thread Local Storage, TLS）。在64位模式下，可以通过`fs`寄存器进行绝对地址访问，这使得它在某些情况下非常有用[3]。

需要注意的是，在现代操作系统中，通常使用平坦模型（flat model），所有的段寄存器都指向同一个大的内存区域。在这种情况下，这些段寄存器的值通常是固定的，不会经常改变。但是，它们仍然存在，并且在某些特殊情况下会被使用。

在`x86`和`x86-64`体系结构中，`dl`和`gs`都是寄存器，但它们的功能不同。

- `dl`是一个8位的数据寄存器，是`edx`寄存器的低8位。在一些指令中，它被用作操作数[1]。例如，一些IO指令（如`in`和`out`）会使用`dl`寄存器来存储端口号。此外，一些数据移动和算术指令也会使用`dl`寄存器。

- `gs`是一个段寄存器，类似于上文提到的`es`、`ds`、`cs`、`fs`和`ss`。在某些操作系统和应用程序中，`gs`寄存器被用于访问特定的数据结构，如线程局部存储（Thread Local Storage, TLS）。在64位模式下，可以通过`gs`寄存器进行绝对地址访问，这使得它在某些情况下非常有用[2]。

需要注意的是，在现代操作系统中，通常使用平坦模型（flat model），所有的段寄存器都指向同一个大的内存区域。在这种情况下，这些段寄存器的值通常是固定的，不会经常改变。

在`x86-64`体系结构中，`ax`、`bx`、`cx`和`di`都是通用寄存器，用于存储临时数据和函数的参数[1]。以下是它们各自的功能：

- `ax`：这是累加器寄存器，通常用于存储算术和逻辑指令的结果。在一些指令中，比如乘法和除法，它会与`dx`寄存器一起使用[2]。

- `bx`：这是基址寄存器，通常用于存储内存地址。在某些地址计算指令中，它会与`si`或`di`寄存器一起使用[2]。

- `cx`：这是计数寄存器，通常用于存储循环和字符串操作的计数值。在一些循环指令（如`loop`）和字符串操作指令（如`rep movsb`）中，它会被用作计数器[2]。

- `di`：这是目标索引寄存器，通常用于存储字符串操作的目标地址。在一些字符串操作指令（如`movsb`）中，它会被用作目标地址的指针[2]。

需要注意的是，在64位模式下，这些寄存器都有对应的64位版本（分别为`rax`、`rbx`、`rcx`和`rdi`），并且可以通过使用不同的寄存器名称来访问它们的不同部分。例如，可以通过使用名称`al`、`ah`、`ax`或者`rax`来分别访问累加器寄存器的低8位、高8位、低16位或全部64位[1]。

### test指令

在`NASM`（Netwide Assembler）汇编语言中，`test`指令用于执行按位`AND`操作，但它不会保存结果，只会影响标志寄存器[1]。这使得它常常被用于测试寄存器或内存位置的特定位。

`test`指令的一般形式是：`test dest, src`。这条指令会执行`dest AND src`操作，并根据结果设置或清除`ZF`（零标志）和`SF`（符号标志）[1]。如果结果为零，则`ZF`被设置；如果结果的最高位（符号位）为1，则`SF`被设置。

例如，以下的汇编代码：

```assembly
mov eax, 5
test eax, eax
jz zero
```

在这个例子中，`test eax, eax`会执行`5 AND 5`操作，结果是5，不为零，所以不会跳转到`zero`标签。

总的来说，`test`指令的主要作用是测试寄存器或内存位置的特定位，并根据结果影响标志寄存器。

### lgdt指令

在`NASM`汇编语言中，`lgdt`（Load Global Descriptor Table Register）指令用于加载全局描述符表寄存器（GDTR）[2]。全局描述符表（Global Descriptor Table，简称GDT）是在保护模式下用于定义段的数据结构，每一个段都由一个描述符来表示，而这些描述符则存储在GDT中。

`lgdt`指令的一般形式是：`lgdt m`。这条指令会把内存位置`m`中的值加载到GDTR中[2]。需要注意的是，`m`必须是一个内存操作数，不能是立即数[4]。

例如，以下的汇编代码：

```assembly
lgdt [gdtr]
```

在这个例子中，`lgdt [gdtr]`会把内存位置`gdtr`中的值加载到GDTR中。这个值通常是一个48位的值，其中32位是GDT的基地址，16位是GDT的界限[2]。

总的来说，`lgdt`指令的主要作用是加载全局描述符表寄存器。它通常在实地址模式中执行，以便处理器在切换到保护模式之前进行初始化[3]。

### cld指令

在x86_64架构中，`cld`是一个汇编指令，全称为"Clear Direction Flag"，意为清除方向标志。

在x86架构的CPU中，有一个标志寄存器（FLAGS或EFLAGS），其中的一个位是方向标志（Direction Flag，DF）。DF标志用于控制某些字符串操作指令（如`movs`, `scas`, `cmps`, `stos`, `lods`等）的处理方向。当DF设置为0时，这些指令操作的内存地址将从低地址向高地址递增；当DF设置为1时，这些指令操作的内存地址将从高地址向低地址递减。

`cld`指令就是用来清除（即设置为0）DF标志的。执行`cld`指令后，相关的字符串操作指令将会从低地址向高地址操作内存。

## 异常相关

在`x86`架构中，`double fault`是一种特殊的处理器异常，它在处理器尝试服务一个待处理的中断或异常时遇到问题时发生[4]。换句话说，当CPU执行错误处理函数失败时，会抛出`double fault`异常[2]。

通常情况下，当处理器在尝试调用一个先前异常的处理程序时检测到一个异常，这两个异常可以被顺序处理。然而，如果处理器无法顺序处理这两个异常，它就会发出`double fault`异常信号[3]。

例如，如果你没有在中断描述符表中注册对应的`page fault`异常处理函数，然后程序抛出了一个`page fault`异常，这时候就会接着抛出`double fault`异常[2]。另一个例子是，当触发一个中断，但中断处理程序所在的段无效时，也会发生`double fault`[4]。

总的来说，`double fault`在`x86`架构中是一种处理器异常，它在处理器尝试服务一个待处理的中断或异常时遇到问题时发生。

### apic

在`x86`架构中，APIC（Advanced Programmable Interrupt Controller）是一种高级可编程中断控制器，用于处理和分发处理器的中断请求[1]。

在`x86`架构中，主要有两种类型的APIC：Local APIC和I/O APIC[2]：

- **Local APIC**：每个处理器都有一个Local APIC，主要用于处理处理器之间的中断（被称为interprocessor interrupts，简称IPIs）。Local APIC主要通过ICR（interrupt command register）来发送IPIs[2]。

- **I/O APIC**：用于接收外部设备的中断请求，并将这些请求转发给适当的Local APIC[2]。

当外部设备发出中断信号时，I/O APIC会将这个信号封装成有格式的中断消息，然后发送给相应的Local APIC。然后，Local APIC会根据一系列决策机制决定将这个中断请求发送给哪个CPU进行处理[1]。

总的来说，APIC在`x86`架构中起到了处理和分发处理器的中断请求的作用。

## `__forceinline`和`inline`这两个关键字有什么区别？

`inline`和`__forceinline`都是C++中用于函数内联的关键字，但它们的作用和影响是不同的。

`inline`是C++和C99的标准关键字，用于建议编译器将函数内联，即将函数调用替换为函数体[1]。但这只是一个建议，编译器可以选择忽略这个建议，如果它认为内联这个函数会导致性能下降或其他问题[4]。

相比之下，`__forceinline`是一个非标准的关键字，主要在MSVC（Microsoft Visual C++）中使用。它比`inline`更强硬，会强制编译器将函数内联，即使编译器认为这可能会导致问题[1]。这可能会导致生成的可执行文件膨胀，以及指令缓存命中率降低[3]。然而，在某些特殊情况下，比如一个复杂计算需要在一个地方多次调用同一个函数时，使用`__forceinline`可能会有所帮助[2]。

总的来说，`inline`和`__forceinline`都可以用于指导编译器进行函数内联，但`__forceinline`比`inline`更强硬，会强制编译器进行内联，而不只是提供一个建议。

### PIC

在x86-64架构中的可编程中断控制器（PIC）中，Master（主）和Slave（从）是指两个不同的PIC芯片。

Master PIC负责处理CPU的中断请求，并控制系统中的中断分发。它有一个特殊的引脚（IRQ2），用于与Slave PIC进行通信。

Slave PIC是连接到Master PIC的第二个PIC芯片。它扩展了系统的中断处理能力，增加了更多的中断向量。Slave PIC通过与Master PIC的IRQ2引脚连接来进行通信。

通过Master和Slave之间的协作，PIC可以处理更多的中断请求，并将它们传递给CPU进行处理。这种架构允许系统处理更多的硬件中断，并提高系统的可靠性和性能。

### stosb

`stosb` 是x86-64架构中的一条汇编指令，它的功能是将 `AL` 寄存器中的内容复制到 `EDI` 或 `DI` 寄存器指向的内存位置，并根据方向标志（Direction Flag, DF）增加或减少目标地址。

具体来说，`stosb` 指令会执行以下操作：

1. 如果方向标志DF为0，那么它会将 `AL` 寄存器中的内容复制到 `EDI` 或 `DI` 寄存器指向的内存位置，然后将 `EDI` 或 `DI` 增加1（因为一个字节是1字节，或8位）[2]。
2. 如果方向标志DF为1，那么它会将 `AL` 寄存器中的内容复制到 `EDI` 或 `DI` 寄存器指向的内存位置，然后将 `EDI` 或 `DI` 减少1[2]。

这个指令通常用于实现内存填充操作，例如在实现字符串填充、内存块填充或者系统调用如memset等函数时可能会使用到。

### movsb

`movsb` 是x86-64架构中的一条汇编指令，它的功能是从源地址复制一个字节到目标地址，并根据方向标志（Direction Flag, DF）增加或减少源地址和目标地址。

具体来说，`movsb` 指令会执行以下操作：

1. 如果方向标志DF为0，那么它会从源地址（存储在SI或者ESI寄存器中）复制一个字节到目标地址（存储在DI或者EDI寄存器中），然后将SI或者ESI和DI或者EDI都增加1（因为一个字节是1字节，或8位）[2]。
2. 如果方向标志DF为1，那么它会从源地址（存储在SI或者ESI寄存器中）复制一个字节到目标地址（存储在DI或者EDI寄存器中），然后将SI或者ESI和DI或者EDI都减少1[2]。

这个指令通常用于实现内存复制操作，例如在实现字符串复制、内存块复制或者系统调用如memcpy等函数时可能会使用到。